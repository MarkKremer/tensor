// Code generated by genlib2. DO NOT EDIT.

package tensor

import (
	"reflect"
	"unsafe"

	"github.com/pkg/errors"
)

func checkNativeSelectable(t *Dense, axis int, dt Dtype) error {
	if !t.IsNativelyAccessible() {
		return errors.New("Cannot select on non-natively accessible data")
	}
	if axis >= t.shape.Dims() && !(t.IsScalar() && axis == 0) {
		return errors.Errorf("Cannot select on axis %d. Shape is %v", axis, t.shape)
	}
	if t.DataOrder().isColMajor() || t.RequiresIterator() {
		return errors.Errorf("Not yet implemented: native select for colmajor or unpacked matrices")
	}
	if t.Dtype() != dt {
		return errors.Errorf("Native selection only works on %v. Got %v", dt, t.Dtype())
	}
	return nil
}

/* Native Select for bool */

// NativeSelectB creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectB(t *Dense, axis int) (retVal [][]bool, err error) {
	if err := checkNativeSelectable(t, axis, Bool); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]bool, 1)
		retVal[0] = t.Bools()
	case 2:
		if axis == 0 {
			return NativeMatrixB(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Bools()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]bool, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]bool)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for int */

// NativeSelectI creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectI(t *Dense, axis int) (retVal [][]int, err error) {
	if err := checkNativeSelectable(t, axis, Int); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]int, 1)
		retVal[0] = t.Ints()
	case 2:
		if axis == 0 {
			return NativeMatrixI(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Ints()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]int, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]int)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for int8 */

// NativeSelectI8 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectI8(t *Dense, axis int) (retVal [][]int8, err error) {
	if err := checkNativeSelectable(t, axis, Int8); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]int8, 1)
		retVal[0] = t.Int8s()
	case 2:
		if axis == 0 {
			return NativeMatrixI8(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Int8s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]int8, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]int8)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for int16 */

// NativeSelectI16 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectI16(t *Dense, axis int) (retVal [][]int16, err error) {
	if err := checkNativeSelectable(t, axis, Int16); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]int16, 1)
		retVal[0] = t.Int16s()
	case 2:
		if axis == 0 {
			return NativeMatrixI16(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Int16s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]int16, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]int16)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for int32 */

// NativeSelectI32 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectI32(t *Dense, axis int) (retVal [][]int32, err error) {
	if err := checkNativeSelectable(t, axis, Int32); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]int32, 1)
		retVal[0] = t.Int32s()
	case 2:
		if axis == 0 {
			return NativeMatrixI32(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Int32s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]int32, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]int32)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for int64 */

// NativeSelectI64 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectI64(t *Dense, axis int) (retVal [][]int64, err error) {
	if err := checkNativeSelectable(t, axis, Int64); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]int64, 1)
		retVal[0] = t.Int64s()
	case 2:
		if axis == 0 {
			return NativeMatrixI64(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Int64s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]int64, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]int64)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for uint */

// NativeSelectU creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectU(t *Dense, axis int) (retVal [][]uint, err error) {
	if err := checkNativeSelectable(t, axis, Uint); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]uint, 1)
		retVal[0] = t.Uints()
	case 2:
		if axis == 0 {
			return NativeMatrixU(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Uints()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]uint, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]uint)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for uint8 */

// NativeSelectU8 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectU8(t *Dense, axis int) (retVal [][]uint8, err error) {
	if err := checkNativeSelectable(t, axis, Uint8); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]uint8, 1)
		retVal[0] = t.Uint8s()
	case 2:
		if axis == 0 {
			return NativeMatrixU8(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Uint8s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]uint8, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]uint8)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for uint16 */

// NativeSelectU16 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectU16(t *Dense, axis int) (retVal [][]uint16, err error) {
	if err := checkNativeSelectable(t, axis, Uint16); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]uint16, 1)
		retVal[0] = t.Uint16s()
	case 2:
		if axis == 0 {
			return NativeMatrixU16(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Uint16s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]uint16, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]uint16)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for uint32 */

// NativeSelectU32 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectU32(t *Dense, axis int) (retVal [][]uint32, err error) {
	if err := checkNativeSelectable(t, axis, Uint32); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]uint32, 1)
		retVal[0] = t.Uint32s()
	case 2:
		if axis == 0 {
			return NativeMatrixU32(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Uint32s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]uint32, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]uint32)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for uint64 */

// NativeSelectU64 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectU64(t *Dense, axis int) (retVal [][]uint64, err error) {
	if err := checkNativeSelectable(t, axis, Uint64); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]uint64, 1)
		retVal[0] = t.Uint64s()
	case 2:
		if axis == 0 {
			return NativeMatrixU64(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Uint64s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]uint64, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]uint64)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for float32 */

// NativeSelectF32 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectF32(t *Dense, axis int) (retVal [][]float32, err error) {
	if err := checkNativeSelectable(t, axis, Float32); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]float32, 1)
		retVal[0] = t.Float32s()
	case 2:
		if axis == 0 {
			return NativeMatrixF32(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Float32s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]float32, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]float32)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for float64 */

// NativeSelectF64 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectF64(t *Dense, axis int) (retVal [][]float64, err error) {
	if err := checkNativeSelectable(t, axis, Float64); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]float64, 1)
		retVal[0] = t.Float64s()
	case 2:
		if axis == 0 {
			return NativeMatrixF64(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Float64s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]float64, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]float64)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for complex64 */

// NativeSelectC64 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectC64(t *Dense, axis int) (retVal [][]complex64, err error) {
	if err := checkNativeSelectable(t, axis, Complex64); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]complex64, 1)
		retVal[0] = t.Complex64s()
	case 2:
		if axis == 0 {
			return NativeMatrixC64(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Complex64s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]complex64, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]complex64)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for complex128 */

// NativeSelectC128 creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectC128(t *Dense, axis int) (retVal [][]complex128, err error) {
	if err := checkNativeSelectable(t, axis, Complex128); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]complex128, 1)
		retVal[0] = t.Complex128s()
	case 2:
		if axis == 0 {
			return NativeMatrixC128(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Complex128s()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]complex128, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]complex128)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}

/* Native Select for string */

// NativeSelectStr creates a slice of flat data types. See Example of NativeSelectF64.
func NativeSelectStr(t *Dense, axis int) (retVal [][]string, err error) {
	if err := checkNativeSelectable(t, axis, String); err != nil {
		return nil, err
	}

	switch t.shape.Dims() {
	case 0, 1:
		retVal = make([][]string, 1)
		retVal[0] = t.Strings()
	case 2:
		if axis == 0 {
			return NativeMatrixStr(t)
		}
		fallthrough
	default:
		// size := t.shape[axis]
		data := t.Strings()
		stride := t.strides[axis]
		upper := ProdInts(t.shape[:axis+1])
		retVal = make([][]string, 0, upper)
		for i, r := 0, 0; r < upper; i += stride {
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[i])),
				Len:  stride,
				Cap:  stride,
			}
			retVal = append(retVal, *(*[]string)(unsafe.Pointer(hdr)))
			r++
		}
		return retVal, nil

	}
	return
}
